[{"content":"导语 ucas2023秋 林璟锵、马存庆 网络认证技术笔记\n说是开课以来从未有过挂科选手，但是想得不错的分数还是要努努力，进自己脑子的知识才是最好的知识\n笔记 网络认证技术 ≈ 密码学+计算机网络\n网络认证：在信息系统/网络环境中，实现身份的确认。目标：在不可信的网络环境中确认主体是谁，有什么属性、权限、能力\n身份确认的主体：人、设备、软件服务……\nPKI：公钥基础设施\nCA：认证中心，生成数字证书\nCA是PKI的核心组成成分，但是在很多地方把CA和PKI混用了。\n考试用 两个半小时\n题型：\n判断 2分 简答 5-8分 建议不要空这 关键是原理之类的要记住的\n01 导言（意义不大） 相关概念\n02 密码学基础（会涉及题目，需要复习复习） 对称：加解密\n非对称：签名\n光看密钥长度不能知道强度，RSA1024bits=ECC160bits。短密钥可以达到高强度\n哈希：验证\n消息鉴别码：MAC=C(K,M)，K为密钥M为消息，把密钥跟着一块哈希了\n可鉴别加密CCM、GCM、AEAD（简单了解）\n国外的密码基本原理不细说了\n国产的了解一下\nSM2 非对称 ECC \u0026mdash; 椭圆曲线 知道基于椭圆曲线域上的离散对数困难问题。 替换RSA\nSM3 哈希 256bit和sha256差不多 分组长度512bit，摘要值长度256bit\nSM4 分组工作模式\nECB：对每个块独立加密：明文同样的块会加密成同样的密文\nCBC：明文先与上一个密文异或在加密，需要初始化向量\nOFB：将块密码转为流密码，生成密钥流的块\nCTR（ICM、SIC）：将块密码变为流密码，通过递增加密计数器产生密钥流\nZUC 流密码\n128位的初始密钥key和128位的初始向量iv来作为输入。每个时钟周期能生成32bit\n共享密钥问题-\u0026gt;为什么要有非对称的原因-\u0026gt;数字签名\n03 口令鉴别 client 用复杂口令，不要告诉别人，次数限制\n传输 使用已被验证的安全信道\nserver 存储，验证\n04 基于密码技术的鉴别 两大类：\n对称： 有没有密钥\n提一个协议框架，让你看有没有什么错，一些参数有什么用【用什么方式可以抵抗什么攻击】\nreplay attack（重放攻击）：通过加一个nonce抵抗\noracle session attack（就是攻击者使另一方帮自己来计算）：让u和v不同。比如u为加密，v为解密，被挑战方只能加密，就不能被当成解密服务器了。\nParallel Session attack：p(), q()与方向有关。从而攻击者不能利用服务器的计算。比如发起者会加一个xor，被挑战者会加一个左移\noffset attack：\n把返回的东西改为E(f()#E(g))\n可信第三方，kobras\n非对称：数字签名和验证\n单向（带一个时间戳之类的约定好的东西）、双向（A发给B后B还要发给A）\nPPT标红好好看看\n05+06 PKI技术 CA：认证机构，权威第三方，公钥（证书）可信发布[根CA、子CA]\nRA：注册机构，审查信息，防止CA职能太多导致一个出问题导出都出问题\nrepository（存数据的吧）\nCRL（Certificate Revocation List，证书撤销列表）\nOnline Certificate Status Protocol（OCSP）一种通信协议，专门用于检查证书是否已经被撤销 相应的服务器称为OCSP Server-\u0026gt;（证书有三种状态）Good、Revoked、Unknown ：未撤销、已经撤销、未知\nASN.1-基本数据类型-DER编码-sequence-implicit/explicit tag 稍微看一下\n07 证书拓展 证书基本域\n证书扩展域 X.509版本3 18种，了解功能即可\n拓展有关键和非关键，如果关键出了错（识别不出来），直接认定证书非法。非关键出错则忽略拓展\nBasic Constraints：区分是否是CA证书（能否签发其他证书）以及路径的深度（说明CA可以有多少层次的下级）\nAuthority Key Identifier：证书链中可能有多个公钥，这个确定哪个是用来验证证书的颁发者（CA）的公钥\nSubject Key Identifier：证书链中可能有多个公钥，确定哪个是证书自己的公钥\nKey Usage：密钥的用途。7种+2种辅助用途\nPrivate Key Usage Period：给出证书有效的开始到结束的时间\nIssuer Alternative Name：放置签发者（CA）的消息（DN存放CA信息，子CN没法用DN，就用这来放）\nSubject Alternative Name：放置证书拥有者的消息\nSubject Directory Attributes：可加入任何与Subject有关的信息，例如，民族、生日等\nName Constraints：限制下级CA所能够签发证书的订户的名字空间（只在下级CA中有用）\nCertificate Policies（CP）：区分不同证书的安全等级\nInhibit Any-Policy：（CP的Any-Policy指对于该CA所签发的订户证书的CP没有限制），值是整数N，表示：在证书路径中，本证书之下的N个证书可带有Any-Policy的证书\nPolicy Mappings：说明了不同CA域之间的CP等级的相互映射关系\nPolicy Constraints：对于证书认证路径的策略映射过程中，有关CP的处理，进行限制。N：在N个证书后，不允许再进行策略映射；M：在M个证书后，就必须要有认识的、明确的CP\nExtended Key Usage：证书/密钥可用的用途（拓展）\nCRL Distribution Points：和应用系统约定在哪儿获取CRL\nFreshest CRL：增量CRL情况下，获取最新的增量CRL的地址\nAuthority Information Access：如何在Internet上面，访问一些CA的信息（目前只有 1、上级CA的情况 2、OCSP服务器的情况两个信息）\nSubject Information Access： l如何在Internet上面，访问一些用户的信息 （目前只有 1、资料库的地址（针对CA）2、TSA服务地址（针对TSA服务器））\n08 PKI信任体系 信任模型\n单根CA\n多根CA 根之间要互相通信-CTL（用户自主+权威发布）沟通方式、原理、优缺点，应用\nCTL（信任锚）由权威机构统一地发布1个可信的信任锚列表（Certificate Trust List）包括多个根CA证书文件的HASH结果和受信任CA对其签名\n【信任锚里有根CA证书的hash、其他CA证书、CRL、信任策略和规则等。然后由一个我信任的CA对CTL签名，一般不用CTL里信任的CA来签名。】\n方式：1、不同PKI域用同一个CTL 2、加一个ACA的信任锚说明哪些根CA是可以信任的\n交叉认证-网状mesh-\u0026gt;桥CA\n相当于将对方CA认作是我的子CA。\nmesh-\u0026gt;信任链变成信任网\n桥CA-\u0026gt;不同域之间的证书传递\n09 证书撤销 验证签名-验证有效期-验证撤销状态\n撤销状态 CRL、OCSP、CRT 原理\nCA/CRL Issuer定期地签发CRL CRL，certificate revocation list\n完全CRL－Complete CRL：所有CRL信息一次发布\n增量CRL－Delta CRL：发布新增的CRL信息发布\n直接CRL－Direct CRL：证书签发者签发CRL\n间接CRL－Indirect CRL：使用CRL issuer签发CRL\nOCSP在线证书状态协议 Online Certificate Status Protocol 在线服务器\nCRT：证书撤销树，对于各证书序列号进行一定的结构化，形成了HASH链\n使用了merkle hash tree【区块链信任算法】\n拿加粗的子哈希算哈希，就可以推出根hash，验证起来需要更少的那啥\n10 TLS handshake怎么shake的\n增加一个server对client的鉴别\n如果server证书只能签名不能加密，则要生成一个临时公钥，签名后发给client【ServerKeyExchange】\n两张图里的消息有什么含义 1.3和1.2的区别\n直接在client hello中发了选择算法的key（用server 公钥加密）\n10.5wifi认证 WPA-PSK共享口令 （路由器上做）\nWPA-802.1X 基于账号的身份鉴别 （身份鉴别server）\n客户端或网页 （微信、短信）\n11 不考 12 PKI安全增强 入侵容忍 解决了什么问题？怎么解决的 原理 解决了在入侵场景下的高可用。黑客侵入了其中一个PKI节点无法获利，同时PKI系统任然保持可用性\n【门限密码学：把密钥分成L份，当有其中f+1份时可以解密，否则解密不了】\neg. Shamir\u0026rsquo;s Secret Sharing 基于拉格朗日插值法\neg2. ITTC 基于离散对数的子密钥分配\nserver上用密码算，CA来整合\n也就是说黑客就算攻入了一个节点，他仍然无法获取PKI用来签名证书的私钥，同时其他节点还能继续工作。\n信任增强 解决方式原理 信任机制基本假设：1、CA行为不会出错，证书中的信息不会出错【只有可能是错误操作导致的签发给错误的人】 2、无限制权利\n三个思路：\n1、 浏览器端实施检测：\n（1）浏览器维护证书信息\n（2）多个会话之间互相比较\n2、限制CA权利\n（1）假定server只会向同一个国家的CA申请证书\n（2）限定CA能签发的顶级域名范围\n（3）域名拥有者可以控制哪个CA给他签发证书\n（4）server再次确认机制：\nserver在多一个sovereign Key的公私钥对挂在timeline上，浏览器看到timeline上有sovereign Key，会要求server再次拿sovereign Key私钥签名，黑客控制了CA，却无法获取server的sovereign Key私钥，因此仍然无法伪造身份\n3、证书透明化：\n假定CA也会出错，审计CA\n13 证书透明化 虚假证书：证书可以被严格验证通过，但是证书对应的私钥并不被证书主体拥有，而是被其他人拥有（CA被人黑了，一顿乱发）\n透明化增加哪些步骤SCT相关特点弄清楚一点\n增加\n公开日志服务器（Public Log Server）：保存和维护记录证书的公开日志（Public Log）\n收到证书并验证通过后，公开日志服务器会向提交者返回一个凭据（SCT）Signed Certificate Timestamp。（有可能多个公开日志服务器，就会返回多个SCT）用户不仅需要验证证书，还需要验证相应的SCT（将SCT放入证书中，作为证书扩展）\n用户不仅需要验证证书，还需要验证相应的SCT（将SCT放入证书中，作为证书扩展）\r怎么获得SCT呢？\r1.从X.509证书扩展项获得SCT\r2.从连接建立时TLS扩展项获得SCT -\u0026gt;TLS客户端要支持\r3.从OCSP stapling的扩展项获得SCT\r下面不重要\n监视员（Monitor）：周期性的访问公开日志服务器，寻找和发现可疑的证书 审计员（Auditor）：审计公开日志的行为 14 隐式证书 传统和隐式的结构和使用的区别\n在带宽、计算能力、存储资源有限制的环境下，隐式证书是传统X.509证书的一种高效替代\nX.509证书基本内容：订户身份信息+公钥数据+CA数字签名\n隐式证书基本内容：中间公钥数据$P_U$ + 订户身份标识。 最终公钥 P=$P_{CA}$+$P_U$以及身份信息也有关 $P_{CA}$：CA证书公钥\n使用：\nX.509： 需要对订户证书进行CA签名的验证\n隐式证书：需要重构出订户公钥，在对消息的验签时同时完成对证书本身的验证\n隐式证书中，没有对CA数字签名的验证，取而代之的是，重构公钥的计算，后者的计算量较小。\n假名证书不考\n15 kerberos 可信第三方TTP，基于对称密码，也支持在某些过程使用非对称\n获得一个TGT，用TGT和要访问的目，请求问kerberos服务器，来获取访问目标的票据（不是TGT，TGT只是告诉kerberos我已经被验证过了）\nkerberos票据流程\n长期密钥（主密钥）Long-term Key/Master Key： 长期保持不变的密钥。被长期密钥（主密钥）加密的数据尽量不在网络上传输。（防止暴力破解、分析）\n短期密钥（会话密钥）Short-term Key/Session Key： 加密需要进行网络传输的数据。只在一段时间内有效，即使被加密的数据包被黑客截获并破解成功后，这个Key早就已经过期了。\nKDC（Key Distribution Center）：kerberos server作为可信第三方，维护所有帐户（client、server）的注册信息、用户名、口令、用户主密钥、服务器主密钥\nServer 与Client之间基于共享秘密短期密钥key实现身份鉴别\nKDC仅仅是允许进入应用系统，至于有什么权限、由应用系统自主决定\n获取TGT：\nclient发请求，KDC用client的master key加密一个会话密钥$S_{KDC-Client}$，用KDC的master key加密TGT，TGT里包含会话密钥和client信息（让client 鉴别KDC是KDC而非被伪造）\n获取ST：\n这个图有问题，KDC还给client的不是用clinet的master key，而是用session key。\n当client要访问server的时候，给KDC自己的TGT和要访问的server。\nKDC根据TGT来对client进行认证，生成$S_{Server-Client}$和ST(session ticket)\n$S_{Server-Client}$：用client的主密钥加密一个会话密钥，\nST：用server的主密钥加密，ST包含会话密钥和client的信息。\n将这两个被加密的Copy一并发送给Client\nclient得到会话密钥后，用session key解密，创建Authenticator（Client Info + Timestamp）并用会话密钥加密\nclient将ST和Authenticator访问server，server用自己的主密钥解密ST得到会话密钥，在用会话密钥解密Authenticator，比较Authenticator里的client info和ST里的client info来确定client就是client\n那如果TGT没过期，session key过期了呢？可以用TGT再申请一个，因为TGT用KDC的master key加密，KDC可以得到旧的session key和client info，进而再发一个session key。由于session key是TGT的一部分，这其实也就相当于重新申请了TGT\nclient鉴别server（双向鉴别）：\n在Authenticator里在加一个flag要求server自证。\nserver看到后，用ST里得到的会话密钥解密Authenticator，把里面的timestamp用会话密钥加密发给client\n16 OAuth\u0026amp;OIDC 单点登录(Single Sign on)在某个地方认证了之后，在整个域里都不用再认证了。\nSSO 口令记录器-\u0026gt;保存在edge/chrome\nOAuth 协议流程图，理解认证的流程，有那几个角色，分别做了什么\nOIDC 协议流程图，理解认证的流程\n17 FIDO 在服务器端将用户与移动终端的可信环境进行身份绑定 将用户与服务器之间的直接鉴别转变为两段式鉴别 1 移动终端鉴别用户主要是靠生物特征 2 服务器端鉴别移动终端主要是靠数字签名\n","date":"2023-12-27T19:07:10+08:00","permalink":"https://pillar23.github.io/p/%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/","title":"网络认证技术笔记"},{"content":"为了避免跨平台的问题，直接用choco在windows上安装openssl 3.1.1\nchoco install openssl\n首先生成私钥\n1 openssl genrsa -aes256 -out private.pem 4096 其中\ngenrsa是openssl的一个命令，用于生成RSA私钥。\n-aes256表示在输出私钥之前，使用AES 256加密\n-out private.pem 表示将生成的私钥输出到名为private.pem的文件中\n4096表示生成的私钥的位数，即私钥的长度为4096位\n然后使用私钥生成证书\n1 openssl req -new -x509 -days 365 -key .\\private.pem -out cacert.crt -config .\\smime.cnf -extensions smime 其中\nreq是openssl的一个命令，用于创建和处理PKCS#10格式的证书请求。\n-new表示创建一个新的证书请求。\n-x509表示生成一个自签名的证书，而不是生成一个证书请求。\n-days 365表示生成的证书的有效期为365天。\n-key .\\private.pem表示使用名为private.pem的文件中的私钥来签署证书。\n-out cacert.crt表示将生成的证书输出到名为cacert.crt的文件中。\n-config .\\smime.cnf表示使用名为smime.cnf的文件作为配置文件。\n-extensions smime表示应该包含配置文件中名为smime的部分中指定的扩展。\nsmime的部分为\n1 2 3 4 5 6 7 [smime] basicConstraints = CA:FALSE keyUsage = nonRepudiation, digitalSignature, keyEncipherment extendedKeyUsage = emailProtection subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always, issuer subjectAltName = email:copy basicConstraints = CA:FALSE指定证书不能用作CA（证书颁发机构）\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment指定证书的公钥可以用于哪些用途。这个证书可以用于非否认（nonRepudiation）、数字签名（digitalSignature）和密钥封装（keyEncipherment）\nextendedKeyUsage = emailProtection用于电子邮件保护（emailProtection）\nsubjectKeyIdentifier = hash用公钥的hash值唯一地标识证书中的公钥。\nauthorityKeyIdentifier = keyid:always, issuer用于标识签署此证书的CA的公钥。这个扩展通常包含CA公钥的keyid（一个唯一标识符），以及CA的名称（issuer）。keyid:always表示总是包含keyid，无论是否需要\nsubjectAltName = email:copy用于指定证书的主题可选名称（Subject Alternative Name）。主题可选名称是电子邮件地址，该地址从证书的主题名称字段中复制\n生成的时候国家地区公司啥的都不重要，我直接敲回车按默认了。邮箱写自己的就行了。\n直接用windwos自带的证书查看器查看这个证书。\n版本v3是指我们使用了x.509第3版本，然后序列号是有证书生成算法生成的，唯一的指定这个证书，像身份证号似的。签名算法和哈希算法是一个声明，颁发者是我们刚才在生成证书时写的。有效期由我们刚才的 -days 参数指明，使用者和颁发者一样。\n公钥直接在证书文件里保存。公钥参数0500表示NULL，这是因为RSA的公钥的参数（模数和公开指数）已经在公钥字段中给出，所以不需要在公钥参数字段中再给出，如果是其他的加密算法，可能会包含其他信息。\n基本约束\nSubject Type=End Entity ：这表示该证书是一个终端实体证书，而不是CA（证书颁发机构）证书。也就是说这个证书不能用于签发/创建其他证书。Path Length Constraint=None ：这表示路径长度没有设置，准许其签发多级的数字证书。然而，由于Subject Type=End Entity，这个证书不能用于签发其他证书，所以这个设置在这种情况下没有意义。这是由于我们使用了 basicConstraints = CA:FALSE的选项。\n下面的其他拓展都在-extension部分说过了，这里就不多赘述了。\n然后安装这个证书，并且选择保存路径为受信任的根证书颁发机构\n我使用的客户端是outlook。使用的邮箱服务是qq邮箱。\n在outlook里添加我的证书\n这里outlook只支持导入pfx，所以我们需要把生成的证书格式转换\n1 openssl pkcs12 -export -out cacert.pfx -inkey .\\private.pem -in .\\cacert.crt 接下来是导入助教的证书，首先在outlook里新建一个联系人\n导入，这里又只支持.cer了，我的windows下的openssl好像缺了库没法转，所以用wsl里的openssl转了一下\n1 openssl pkcs12 -in limengjie22\\@mails.ucas.ac.cn.pfx -nokeys -out output.cer openssl pkcs12 -nokeys命令用于从PKCS#12文件（通常具有.pfx或.p12扩展名）中提取证书，-nokeys指定不包含私钥，这样生成的output.cer不能做任何需要私钥的操作（我们也没有要用私钥的操作）\nimport password即使提供的私钥.txt的内容。然后就可以成功导入了\n然后在发送邮件的时候，在选项里把加密和签署都点了\n","date":"2023-11-29T19:56:28+08:00","permalink":"https://pillar23.github.io/p/%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%9A%E4%B8%89/","title":"网络认证技术作业三"},{"content":"导语 ucas 2023秋 网络认证技术\n作业2：任选一个标准（口令鉴别协议），书写阅读报告。报告内容要求描述基本原理，解决了什么问题，可能存在什么问题。\n概述 我选择阅读RFC 7296，该标准是互联网密钥交换 （IKE） 协议的第二个版本。本标准使RFC 5996废弃， IKEv2是当前的互联网标准。\n解决了什么问题 IKEv2（Internet Key Exchange version 2）是一种用于建立虚拟专用网络（VPN）连接的协议，它解决了许多与安全通信和远程访问有关的问题。包括：\n安全性：IKEv2提供了强大的安全性，通过使用加密算法来保护数据的机密性和完整性。它还允许身份验证，以确保通信双方是合法的，并可以抵御各种网络攻击，如中间人攻击和数据篡改。 移动性：IKEv2支持移动设备的连接，允许用户从一个网络切换到另一个网络时保持连接的连续性。这对于移动工作人员或在不同网络环境中工作的人员非常有用。 多平台兼容性：IKEv2是一种通用的VPN协议，支持多种操作系统和设备，包括Windows、macOS、iOS、Android和Linux。这使得它成为广泛使用的VPN协议，能够在不同平台之间建立安全的连接。 快速重新连接：IKEv2具有快速重新连接的能力，可以在断开连接后快速重新建立连接，而不需要用户手动干预。这对于移动设备或不稳定的网络连接非常有用。 支持IPv6：随着IPv6的推广，IKEv2也提供了对IPv6的良好支持，使其适用于新一代互联网协议。 NAT穿透：IKEv2能够穿越网络地址转换（NAT）设备，这使得它在各种网络环境中都能够正常工作，包括家庭网络和企业网络。 在基本原理-1.1节也简述了IKEv2在特定场景下解决了什么问题。\n基本原理 1.1 使用场景 IP 安全性 （IPsec） 为 IP 数据报提供机密性、数据完整性、访问控制和数据源身份验证，这些服务是通过维护 IP 数据报的源和接收方之间的共享状态来提供的。以手动方式建立此共享状态不能很好地扩展。IKEv2正是这样一个动态建立此状态的协议。IKE 在双方之间执行相互身份验证，并建立 IKE 安全关联 （SA），该关联包含共享机密信息，可用于高效建立用于封装安全有效负载 （ESP） [ESP] 或身份验证标头 （AH） [AH] 的 SA，以及一组加密算法，供 SA 用于保护其承载的流量。IKE 用于在许多不同的场景中协商 ESP 或 AH SA，每种方案都有自己的特殊要求。\n1.1.1 隧道模式下的安全网关到安全网关 在此方案中，IP 连接的两个endpoint都不实现 IPsec，但它们之间的网络节点会保护部分方式的流量。保护对endpoint是透明的，并且依赖于普通路由通过隧道终结点发送数据包进行处理。每个endpoint将宣布其后subnet的地址集，数据包将以隧道模式发送，其中内部 IP 标头将包含实际端点的 IP 地址。\n1.1.2 端点到端点传输模式 在此方案中，IP 连接的两个终结点都实现 IPsec，这是 [IPSECARCH] 中主机的要求。该模式通常使用没有内部 IP 标头。将协商一对地址，以便此 SA 保护数据包。这些endpoint可以根据参与者的 IPsec 身份验证身份实现应用层访问控制。此方案实现了端到端安全性。虽然此场景可能不完全适用于 IPv4 公网，但已在使用 IKEv1 的内网内的特定场景中成功部署。在向 IPv6 过渡期间和采用 IKEv2 期间，应该更广泛地启用它。\n在这种情况下，一个或两个受保护的端点可能位于网络地址转换 （NAT） 节点后面，在这种情况下，必须对隧道数据包进行 UDP 封装，以便 UDP 标头中的端口号可用于标识 NAT “后面”的各个endpoint。\n1.1.3隧道模式下的端点到安全网关 在此方案中，受保护的endpoint（通常是便携式计算机）通过受 IPsec保护的隧道连接回其企业网络。它可能仅使用此隧道访问公司网络上的信息，或者可能通过公司网络将其所有流量通过隧道传输回，以便利用公司防火墙提供的针对基于 Internet 的攻击的保护。在任一情况下，受保护端点都需要一个与安全网关关联的 IP 地址，以便返回到该网关的数据包将转到安全网关并用隧道传回。此 IP 地址可以是静态的，也可以由安全网关动态分配。为了支持后一种情况，IKEv2 包括一种机制（即配置有效负载），发起方请求安全网关拥有的 IP 地址，以便在其 SA 期间使用。\n在这种情况下，数据包将使用隧道模式。在来自受保护endpoint的每个数据包上，外部 IP 标头将包含与其当前位置关联的源 IP 地址（即，将流量直接路由到端点的地址），而内部 IP 标头将包含安全网关分配的源 IP 地址（即，将流量路由到安全网关以转发到端点的地址）。外部目标地址将始终是安全网关的地址，而内部目标地址将是数据包的最终目标。\n在这种情况下，受保护的终结点可能位于 NAT 后面。在这种情况下，安全网关看到的 IP 地址将与受保护端点发送的 IP 地址不同，并且必须对数据包进行 UDP 封装才能正确路由。\n1.2初始交换 使用 IKE 的通信始终从IKE_SA_INIT和IKE_AUTH交换开始（在 IKEv1 中称为阶段 1）。这些初始交换通常由四条消息组成，但在某些情况下，该数字可能会增长。使用 IKE 的所有通信都由请求/响应对组成。我们将首先描述基础交换，然后是变体。第一对消息 （IKE_SA_INIT） 协商加密算法、交换随机数并进行 Diffie-Hellman 交换 [DH]。\n第二对消息 （IKE_AUTH） 对以前的消息进行身份验证，交换身份和证书，并建立第一个子 SA。这些消息的某些部分使用通过IKE_SA_INIT交换建立的密钥进行加密和完整性保护，因此身份对窃听者隐藏，并且所有消息中的所有字段都经过身份验证。有关如何生成加密密钥的信息，请参阅第 2.14 节。（无法完成IKE_AUTH交换的中间人攻击者仍可以看到发起者的身份。\n初始交换后的所有消息都使用在IKE_SA_INIT交换中协商的加密算法和密钥进行加密保护。这些后续消息使用第 3.14 节中描述的加密有效负载的语法，使用第 2.14 节中所述派生的密钥进行加密。所有后续消息都包含加密有效负载，即使它们在文本中称为“空”。对于CREATE_CHILD_SA、IKE_AUTH或信息交换，标头后面的消息是加密的，包含标头的消息是使用为 IKE SA 协商的加密算法进行完整性保护的。\n每个 IKE 消息都包含一个消息 ID 作为其固定标头的一部分。此消息 ID 用于匹配请求和响应，并标识消息的重新传输。\n一些简称如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Notation Payload ---------------------------------------- AUTH Authentication CERT Certificate CERTREQ Certificate Request CP Configuration D Delete EAP Extensible Authentication HDR IKE header (not a payload) IDi Identification - Initiator IDr Identification - Responder KE Key Exchange Ni, Nr Nonce N Notify SA Security Association SK Encrypted and Authenticated TSi Traffic Selector - Initiator TSr Traffic Selector - Responder V Vendor ID 第 3 节介绍了每个有效负载的内容的详细信息。可能选择显示的有效负载将显示在括号中，例如 [CERTREQ];这表示可以选择包含证书请求有效负载。\n初始交流如下：\n发起方→接收方HDR, SAi1, KEi, Ni。\nHDR 包含安全参数索引 （SPI）、版本号、Exchange 类型、消息 ID 和各种标志。SAi1 有效负载声明发起方为 IKE SA 支持的加密算法。KE 有效负载发送发起方的 Diffie-Hellman 值。Ni是发起者的随机数。\n接收方→发起方HDR, SAr1, KEr, Nr, [CERTREQ]。\n响应方从发起方提供的选择中选择加密套件，并在 SAr1 有效负载中表达该选择，完成与 KEr 有效负载的 Diffie-Hellman 交换，并在 Nr 有效负载中发送其随机数。\n在协商的这一点上，每一方都可以生成一个名为 SKEYSEED 的数量（参见第 2.14 节），该 IKE SA 的所有密钥都从中派生出来。以下消息完全加密和完整性保护，邮件头除外。用于加密和完整性保护的密钥派生自 SKEYSEED，称为SK_e（加密）和SK_a（身份验证，又名完整性保护）;有关密钥派生的详细信息，请参见第 2.13 和 2.14 节。为每个方向计算单独的SK_e和SK_a。除了从 Diffie-Hellman 值派生的用于保护 IKE SA 的密钥SK_e和SK_a之外，还派生了另一个数量SK_d，并用于派生子 SA 的进一步密钥材料。符号 SK { \u0026hellip; } 表示这些有效负载已使用该方向的SK_e和SK_a进行加密和完整性保护。\n发起方→接收方HDR, SK {IDi, [CERT,] [CERTREQ,] [IDr,] AUTH, SAi2, TSi, TSr} 。发起方使用 IDi 有效负载断言其身份，证明与 IDi 对应的密钥的知识，完整性使用 AUTH 有效负载保护第一条消息的内容（请参阅第 2.15 节）。它还可能在 CERT 有效负载中发送其证书，并在 CERTREQ 有效负载中发送其信任锚的列表。如果包含任何 CERT 有效负载，则提供的第一个证书必须包含用于验证 AUTH 字段的公钥。可选的有效负载 IDr 使发起方能够指定要与响应方的哪个身份通信。当运行响应程序的计算机在同一 IP 地址上托管多个标识时，这很有用。如果发起方建议的 IDr 不被响应方接受，则响应方可能会使用其他某个 IDr 来完成交换。如果发起方随后不接受响应方使用的 IDr 与所请求的 IDr 不同的事实，则发起方可以在注意到这一事实后关闭 SA。发起方使用 SAi2 有效负载开始协商子 SA。最终字段（以 SAi2 开头）在CREATE_CHILD_SA交换的描述中描述。\n接收方→发起方HDR, SK {IDr, [CERT,] AUTH, SAr2, TSi, TSr}。响应方使用 IDr 有效负载断言其身份，可以选择发送一个或多个证书（再次使用包含用于验证 AUTH 的公钥的证书首先列出），使用 AUTH 有效负载验证其身份并保护第二条消息的完整性，并使用下面在CREATE_CHILD_SA交换中描述的其他字段完成子 SA 的协商。IKE_AUTH交换双方必须验证所有签名和消息身份验证代码 （MAC） 是否正确计算。如果任何一方使用共享密钥进行身份验证，则 ID 有效负载中的名称必须与用于生成 AUTH 有效负载的密钥相对应。由于发起方在IKE_SA_INIT中发送其 Diffie-Hellman 值，因此它必须猜测响应方将从其支持的组列表中选择的 Diffie-Hellman 组。如果发起方猜错了，响应方将使用类型 INVALID_KE_PAYLOAD 的通知有效负载进行响应，指示所选组。在这种情况下，发起方必须使用更正的 Diffie-Hellman 组重试IKE_SA_INIT。发起方必须再次提出其完整的可接受加密套件集，因为拒绝消息未经身份验证，否则主动攻击者可以诱使端点协商弱的套件。\n如果在IKE_AUTH交换期间创建子 SA 由于某种原因而失败，IKE SA 仍会照常创建。IKE_AUTH交换中不阻止设置 IKE SA 的通知消息类型列表至少包括以下内容：NO_PROPOSAL_CHOSEN、TS_UNACCEPTABLE、SINGLE_PAIR_REQUIRED、INTERNAL_ADDRESS_FAILURE和FAILED_CP_REQUIRED。\n如果失败与创建 IKE SA 有关（例如，返回AUTHENTICATION_FAILED通知错误消息），则不会创建 IKE SA。请注意，尽管IKE_AUTH消息已加密且完整性受到保护，但如果收到此通知错误消息的对等方尚未对另一端进行身份验证（或者如果对等方由于某种原因未能对另一端进行身份验证），则需要谨慎对待这些信息。更准确地说，假设MAC正确验证，则已知错误通知消息的发送方是IKE_SA_INIT交换的响应者，但无法保证发送方的身份。\n请注意，IKE_AUTH消息不包含 KEi/KEr 或 Ni/Nr 有效负载。因此，IKE_AUTH交换中的 SA 有效负载不能包含具有除 NONE 以外的任何值的转换类型 4（Diffie-Hellman 组）。实现应该省略整个转换子结构，而不是发送值 NONE。\n1.3 CREATE_CHILD_SA交换 CREATE_CHILD_SA交换用于创建新的子 SA，并重新生成 IKE SA 和子 SA 的密钥。此交换由单个请求/响应对组成，其某些功能在 IKEv1 中称为第 2 阶段交换。在初始交换完成后，它可以由IKE SA的任何一端发起。\n通过创建新 SA，然后删除旧 SA 来重新生成 SA 的密钥。本节介绍重新生成密钥的第一部分，即创建新 SA;第 2.8 节介绍了重新生成密钥的机制，包括将流量从旧 SA 移动到新 SA 以及删除旧 SA。必须一起阅读这两个部分才能理解重新生成密钥的整个过程。\n任一端点都可能发起CREATE_CHILD_SA交换，因此在本节中，术语发起方是指发起此交换的端点。实现可以拒绝 IKE SA 中的所有CREATE_CHILD_SA请求。\nCREATE_CHILD_SA请求可以选择包含用于额外 Diffie-Hellman 交换的 KE 有效负载，以便为子 SA 提供更强有力的前向保密保证。子 SA 的键控材料是 IKE SA 建立期间建立的SK_d、CREATE_CHILD_SA交换期间交换的随机数和 Diffie-Hellman 值（如果 KE 有效载荷包含在CREATE_CHILD_SA交换中）的函数。\n如果CREATE_CHILD_SA交换包含 KEi 有效载荷，则至少有一个 SA 报价必须包括 KEi 的 Diffie-Hellman 组。KEi的Diffie-Hellman组必须是发起者期望响应者接受的组的一个元素（可以提出其他Diffie-Hellman组）。如果响应方使用不同的 Diffie-Hellman 组（NONE 除外）选择提案，则响应方必须拒绝该请求，并在INVALID_KE_PAYLOAD Notify 有效负载中指示其首选的 Diffie-Hellman 组。有两个八位字节的数据与此通知相关联：接受的 Diffie-Hellman 组号，按大端序排列。在此类拒绝的情况下，CREATE_CHILD_SA交换失败，发起方可能会在响应者在INVALID_KE_PAYLOAD通知有效负载中给出的组中使用 Diffie-Hellman 提案和 KEi 重试交换。\n响应方发送NO_ADDITIONAL_SAS通知，以指示CREATE_CHILD_SA请求不可接受，因为响应方不愿意在此 IKE SA 上接受更多的子 SA。此通知还可用于拒绝 IKE SA 重新生成密钥。一些最小实现可能只接受初始 IKE 交换上下文中的单个子 SA 设置，并拒绝任何后续添加更多设置的尝试。\n1.3.1 通过CREATE_CHILD_SA交换创建新的子 SA 可以通过发送CREATE_CHILD_SA请求来创建子 SA。创建新子 SA 的CREATE_CHILD_SA请求是：\n发起方→接收方 HDR, SK {SA, Ni, [KEi,] TSi, TSr}。\n发起方在 SA 有效负载中发送 SA 选件，在 Ni 有效负载中发送随机数，在 KEi 有效负载中发送 Diffie-Hellman 值（可选），并在 TSi 和 TSr 有效负载中发送建议的子 SA 的建议流量选择器。\n接收方→发起方 HDR, SK {SA, Nr, [KEr,]TSi, TSr}\n如果请求中包含 KEi 并且所选加密套件包含该组，则响应程序使用 SA 有效负载中的已接受产品/服务、Nr 有效负载中的随机数和 KEr 有效负载中的 Diffie-Hellman 值进行回复（使用相同的消息 ID 进行响应）。\n要在该 SA 上发送的流量的流量选择器在响应的 TS 有效负载中指定，这可能是子 SA 的发起方建议的子集。\nUSE_TRANSPORT_MODE通知可以包含在请求消息中，该消息还包括请求子 SA 的 SA 有效负载。它要求子 SA 对创建的 SA 使用传输模式而不是隧道模式。如果请求被接受，则响应还必须包含类型 USE_TRANSPORT_MODE 的通知。如果响应方拒绝请求，子 SA 将在隧道模式下建立。如果发起方无法接受，则发起方必须删除 SA。注意：除非使用此选项协商传输模式，否则所有子 SA 都将使用隧道模式。\nESP_TFC_PADDING_NOT_SUPPORTED通知断言发送终结点将不接受在正在协商的子 SA 上填充包含流量流机密性 （TFC） 填充的数据包。如果两个终结点都不接受 TFC 填充，则此通知将包含在请求和响应中。如果此通知仅包含在其中一条消息中，则仍可以在另一个方向发送 TFC 填充。\nNON_FIRST_FRAGMENTS_ALSO通知用于碎片控制。有关更全面的解释，请参见 [IPSECARCH]。双方需要同意在任何一方发送非第一个片段之前发送。仅当建议 SA 的请求和接受 SA 的响应中都包含通知NON_FIRST_FRAGMENTS_ALSO才会启用它。如果响应程序不想发送或接收非第一个片段，则它只会从响应中省略NON_FIRST_FRAGMENTS_ALSO通知，但不会拒绝整个子 SA 创建。\n第 2.22 节中涵盖的IPCOMP_SUPPORTED通知也可以包含在交易所中。\n创建子 SA 的失败尝试不应拆除 IKE SA：没有理由丢失为 IKE SA 所做的工作。有关创建子 SA 失败时可能出现的错误消息列表，请参阅第 2.21 节。\n1.3.2 使用CREATE_CHILD_SA交换机重新生成 IKE SA 的密钥 重新生成 IKE SA 密钥的CREATE_CHILD_SA请求是：\n发起方→接收方HDR, SK {SA, Ni, KEi}\n发起方在 SA 有效负载中发送 SA 产品/服务，在 Ni 有效负载中发送随机数，在 KEi 有效负载中发送 Diffie-Hellman 值。必须包括 KEi 有效负载。新的发起方 SPI 在 SA 有效负载的 SPI 字段中提供。一旦对等方收到重新生成 IKE SA 密钥的请求或发送重新生成 IKE SA 的请求，它就不应在正在重新生成密钥的 IKE SA 上发起任何新的CREATE_CHILD_SA交换。\n接收方→发起方 HDR, SK {SA, Nr, KEr}\n如果所选加密套件包含该组，则响应程序使用 SA 有效负载中的已接受产品/服务、Nr 有效负载中的随机数和 KEr 有效负载中的 Diffie-Hellman 值进行回复（使用相同的消息 ID 进行响应）。新的响应程序 SPI 在 SA 有效负载的 SPI 字段中提供。\n新的 IKE SA 将其消息计数器设置为 0，无论它们在早期的 IKE SA 中是什么。来自新 IKE SA 上双方的第一个 IKE 请求的消息 ID 为 0。旧的 IKE SA 保留其编号，因此任何进一步的请求（例如，删除 IKE SA）都将具有连续编号。新的 IKE SA 的窗口大小也重置为 1，并且此重新密钥交换中的发起方是新 IKE SA 的新“原始发起方”。\n1.3.3. 使用 CREATE_CHILD_SA 交换重新生成子 SA 的密钥 重新生成子 SA 密钥CREATE_CHILD_SA请求是：\n发起方→接收方 HDR, SK {N(REKEY_SA), SA, Ni, [KEi,] TSi, TSr}\n发起方在 SA 有效负载中发送 SA 选件，在 Ni 有效负载中发送随机数，在 KEi 有效负载中发送 Diffie-Hellman 值（可选），并在 TSi 和 TSr 有效负载中发送建议的子 SA 的建议流量选择器。第 1.3.1 节中描述的通知也可以在重新生成密钥交换中发送。通常，这些通知与原始交换中使用的通知相同;例如，重新生成传输模式 SA 的密钥时，将使用USE_TRANSPORT_MODE通知。如果交换的目的是替换现有的 ESP 或 AH SA，则必须将REKEY_SA通知包含在CREATE_CHILD_SA交换中。正在重新生成密钥的 SA 由通知有效负载中的 SPI 字段标识;这是交换发起方在入站 ESP 或 AH 数据包中期望的 SPI。没有与此通知消息类型关联的数据。REKEY_SA通知的协议 ID 字段设置为与我们要重新生成密钥的 SA 的协议匹配，例如，3 表示 ESP，2 表示 AH。\n重新生成子 SA 密钥CREATE_CHILD_SA响应为：\n接收方→发起方 HDR, SK {SA, Nr, [KEr,] TSi, TSr}\n如果请求中包含 KEi 并且所选加密套件包含该组，则响应程序使用 SA 有效负载中的已接受报价、Nr 有效负载中的随机数和 KEr 有效负载中的 Diffie-Hellman 值进行回复（使用相同的消息 ID 进行响应）。\n要在该 SA 上发送的流量的流量选择器在响应的 TS 有效负载中指定，这可能是子 SA 的发起方建议的子集。\n1.4. 信息交换 在 IKE SA 运行过程中的不同点，对等方可能希望相互传达有关某些事件的错误或通知的控制消息。为了实现这一点，IKE 定义了一个信息交换。信息交换必须仅在初始交换之后进行，并使用协商密钥进行加密保护。请注意，某些信息性消息（而非交换）可以在 IKE SA 的上下文之外发送。第 2.21 节还详细介绍了错误消息。\n与 IKE SA 相关的控制消息必须在该 IKE SA 下发送。与子 SA 相关的控制消息必须在生成它们的 IKE SA（如果 IKE SA 已重新生成密钥，则为其后续消息）的保护下发送。\n信息交换中的消息包含零个或多个通知、删除和配置有效负载。信息交换请求的接收者必须发送一些响应;否则，发送方将假定消息在网络中丢失并重新传输。该响应可能是一条空消息。信息交换中的请求消息也可能不包含有效负载。这是终结点可以要求另一个终结点验证其是否处于活动状态的预期方式。\n信息交换定义为：\n发起方→接收方 HDR, SK {[N,] [D,] [CP,] \u0026hellip;}\n接收方→发起方 HDR, SK {[N,] [D,] [CP,] \u0026hellip;}\n信息交换的处理由其组件有效载荷决定。\n1.4.1. 删除具有信息交换的 SA ESP 和 AH SA 始终成对存在，每个方向上有一个 SA。关闭 SA 时，必须关闭（即删除）对的两个成员。每个终结点必须关闭其传入的 SA，并允许另一个终结点关闭每对中的另一个 SA。要删除 SA，将发送具有一个或多个 Delete 有效负载的信息交换，列出要删除的 SA 的 SPI（正如入站数据包标头中预期的那样）。收件人必须关闭指定的 SA。请注意，从不在单个消息中发送 SA 两端的删除有效负载。如果要同时删除多个 SA，则在信息交换中包括每个 SA 对的入站部分的删除有效负载。\n通常，信息交换中的响应将包含向另一个方向的配对 SA 的删除有效负载。有一个例外。如果一组 SA 的两端偶然独立决定关闭它们，则每个 SA 都可能发送 Delete 有效负载，并且这两个请求可能会在网络中交叉。如果节点收到已发出删除请求的 SA 的删除请求，则必须在处理请求时删除传出 SA，在处理响应时删除传入 SA。在这种情况下，响应不得包含已删除 SA 的删除有效负载，因为这会导致重复删除，并且理论上可能会删除错误的 SA。\n与 ESP 和 AH SA 类似，IKE SA 也通过发送信息交换来删除。删除 IKE SA 会隐式关闭根据该 IKE SA 协商的任何剩余子 SA。对删除 IKE SA 的请求的响应是空的信息响应。\n半闭合 ESP 或 AH 连接是异常的，具有审计功能的节点如果它们仍然存在，则可能应该审计它们的存在。请注意，此规范未指定时间段，因此由各个终结点决定等待多长时间。节点可以拒绝接受半闭合连接上的传入数据，但不得单方面关闭它们并重用 SPI。如果连接状态变得足够混乱，节点可能会关闭 IKE SA，如上所述。然后，它可以在新的 IKE SA 下干净的基础上重建所需的 SA。\n1.5 IKE SA 之外的信息性消息 在某些情况下，节点收到无法处理的数据包，但它可能希望将这种情况通知发送方。\n如果 ESP 或 AH 数据包到达时带有无法识别的 SPI。这可能是由于接收节点最近崩溃并丢失状态，或者由于其他一些系统故障或攻击。 如果加密的 IKE 请求数据包到达端口 500 或 4500，并且具有无法识别的 IKE SPI。这可能是由于接收节点最近崩溃并丢失状态，或者由于其他一些系统故障或攻击。 如果 IKE 请求数据包到达时的主版本号高于实现支持的版本号。 在第一种情况下，如果接收节点有一个活动的 IKE SA 到数据包来自的 IP 地址，它可能会在信息交换中通过该 IKE SA 发送任性数据包的INVALID_SPI通知。通知数据包含无效数据包的 SPI。此通知的接收者无法判断 SPI 是针对 AH 还是 ESP，但这并不重要，因为在许多情况下，两者的 SPI 会有所不同。如果不存在合适的 IKE SA，则节点可能会向源 IP 地址发送没有加密保护的信息性消息，如果数据包是 UDP（UDP 封装的 ESP 或 AH），则使用源 UDP 端口作为目标端口。在这种情况下，它应该只被收件人用作可能出错的提示（因为它很容易被伪造）。此消息不是信息交换的一部分，接收节点不得响应它，因为这样做可能会导致消息循环。消息构造如下：没有对此类通知的接收者有意义的 IKE SPI 值;使用零值或随机值都是可以接受的，这是第 3.1 节中禁止零 IKE 发起方 SPI 的规则的例外。发起方标志设置为 1，响应标志设置为 0，版本标志以正常方式设置;这些标志在第 3.1 节中描述。\n在第两种和第三种情况下，消息始终在没有加密保护的情况下发送（在 IKE SA 外部），并且包括INVALID_IKE_SPI或INVALID_MAJOR_VERSION通知（没有通知数据）。该消息是响应消息，因此它被发送到带有相同 IKE SPI 的 IP 地址和端口，并且消息 ID 和交换类型是从请求中复制的。响应标志设置为 1，版本标志以正常方式设置。\n可能存在的问题 参考发表在27th USENIX Security Symposium (USENIX Security 18), 2018的The Dangers of Key Reuse: Practical Attacks on IPsec IKE可IKEv1、v2如果重用密钥可能导致跨协议身份验证绕过，从而使攻击者能够冒充受害者主机或网络。在IKEv1模式下利用Bleichenbacher预言机，其中RSA加密的随机数用于身份验证。利用此漏洞打破了基于 RSA 加密的模式，此外还破坏了 IKEv1 和 IKEv2 中基于 RSA 签名的身份验证。此外，还存在针对基于 PSK（预共享密钥）的 IKE 模式的离线字典攻击，从而涵盖了 IKE 的所有可用身份验证机制。在思科（CVE-2018-0131）、华为（CVE2017-17305）、Clavister（CVE-2018-8753）和合勤科技（CVE-2018-9129）的IKEv1实现中找到了Bleichenbacher预言机。\n","date":"2023-10-19T16:31:55+08:00","permalink":"https://pillar23.github.io/p/ikev2%E6%A0%87%E5%87%86%E9%98%85%E8%AF%BB/","title":"IKEv2标准阅读"},{"content":"导语 果壳的校园网不给直接内网连远程桌面，感觉是因为划的子网之间不能互相通信，不知道是深澜故意的还是不小心的。todesk自然是可以，但是感觉免费的todesk画质略输一筹的同时延迟也有点小高。于是想到用frp的内网穿透来搞p2p的远程桌面。\n操作 实际上还是挺简单的，为数不多的坑是网上的教程都还是ini格式，但是在现在的版本里已经转为了toml、yaml等，而且参数好像也有些变化。\n去github下载frp的releas\n服务端 在你的服务器上装frps，并且配置toml文件，下载的frps.toml已经基本上写好了，基本啥也不用改，只要把最后的插件注释掉（或者你也可以把插件装了用）\n1 2 3 4 5 6 7 8 9 10 11 #[[httpPlugins]] #name = \u0026#34;user-manager\u0026#34; #addr = \u0026#34;127.0.0.1:9000\u0026#34; #path = \u0026#34;/handler\u0026#34; #ops = [\u0026#34;Login\u0026#34;] #[[httpPlugins]] #name = \u0026#34;port-manager\u0026#34; #addr = \u0026#34;127.0.0.1:9001\u0026#34; #path = \u0026#34;/handler\u0026#34; #ops = [\u0026#34;NewProxy\u0026#34;] 再改一下auth.token，这个token是你的frpc也要配置成一样的，相当于server对client的认证。\n1 auth.token = \u0026#34;hsijdfhsjdhf\u0026#34; # 这个感觉可以随便写，多复杂都行，反正你能连上你的服务器就能查 然后再改一改web界面的用户名密码端口啥的或者直接把web也注释了\n1 2 3 4 webServer.addr = \u0026#34;0.0.0.0\u0026#34; webServer.port = 7500 webServer.user = \u0026#34;dgsdgfsdfs\u0026#34; webServer.password = \u0026#34;dweqweas\u0026#34; 然后启动时一定要用-c指定toml配置文件，否则我也不知道他默认找的哪里的配置文件\n客户端 这里使用了xtcp的代理协议来进行p2p的内网穿透，如果想用其他方法可以参考官方文档（？是吗）\n在被控端和控制端都装上对应平台的frpc，并且配置frpc.toml\n配置frps的地址端口和token\n1 2 3 serverAddr = \u0026#34;1.1.1.1\u0026#34; serverPort = 7000 auth.token = \u0026#34;asfggsaddasd\u0026#34; # 这里要和服务端配的一样 把下面哪些示例配置全都注释掉，然后写上下面的内容\n1 2 3 4 5 6 7 [[proxies]] name = \u0026#34;rdesk\u0026#34; type = \u0026#34;xtcp\u0026#34; localIP = \u0026#34;127.0.0.1\u0026#34; # 本机 localPort = 3389 # 远程桌面连接 role = \u0026#34;server\u0026#34; secretKey = \u0026#34;akjndsghnkjadsfjh\u0026#34; 如果你的被控端的frpc设置开了web，那你应该可以再web界面看到你的xtcp的连接\n对了你还可以再你的frps和frpc里都指定一个user，这样你的proxy的name就会变成user.name的形式，这也就使你可以在server端配置多用户（指直接管name叫做aaa.xxx而不配置frps的user）\n同时在控制的机器那边也装上frpc，配置frps的地址端口和token\n1 2 3 serverAddr = \u0026#34;1.1.1.1\u0026#34; serverPort = 7000 auth.token = \u0026#34;asfggsaddasd\u0026#34; # 这里要和服务端配的一样 然后再加上\n1 2 3 4 5 6 7 [[visitors]] name = \u0026#34;rdesk_visitor\u0026#34; type = \u0026#34;xtcp\u0026#34; serverName = \u0026#34;rdesk\u0026#34; # 这里要和上面的name一致 secretKey = \u0026#34;akjndsghnkjadsfjh\u0026#34; # 这里要和上面的secretkey一致 bindAddr = \u0026#34;127.0.0.1\u0026#34; # 本机的ip地址 bindPort = 8000 然后使用frpc的同时也要用-c来指定配置文件\n./frpc.exe -c ./frpc.toml\nvisitors是在web里看不见的，看不到不要觉得奇怪。\n如果在server上可以看到都连上了，直接mstsc连就行了，连127.0.0.1:8000（也就是你在visitor里设置的地址端口）（这里是把log指向了console，所以可以直接看）\nwindwos防火墙会弹，同意了就完事了\n使用systemd让frps挂在后台 直接参考https://gofrp.org/zh-cn/docs/setup/systemd/\n","date":"2023-10-16T14:10:06+08:00","permalink":"https://pillar23.github.io/p/frp%E5%AE%9E%E7%8E%B0%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/","title":"Frp实现隧道穿透远程桌面"},{"content":"First take 旧的博客忘了同步，导致换了电脑之后source找不到了（哭哭 于是整了个新博客儿，采用小号githubpage+hugo的解决方法 当成一个新的云笔记吧，不过其实也搞了本地md+github的方案，但是肯定没有静态博客看着爽了，整，都可以整！ 顺便给旧的hexo博客指路https://blog.pillar.fun\n","date":"2023-10-03T17:54:20+08:00","permalink":"https://pillar23.github.io/p/first_blog/","title":"First_blog"},{"content":"+++ title = \u0026lsquo;Detecting Unknown Encrypted Malicious Traffic in Real Time via Flow Interaction Graph Analysis\u0026rsquo; date = 2023-10-16T20:34:22+08:00 draft = true +++\n导语 doi is here\nAbstract 问题引入 目前互联网上的流量已被广泛加密，同时流量加密总是被攻击者滥用以隐藏其恶意行为，现有的加密恶意流量检测方法受到监督，它们依赖于已知攻击（例如，标记数据集）的先验知识。\n提出方法 提出了HyperVision，一种基于实时无监督机器学习的恶意流量检测系统。\n能够利用基于流量模式构建的紧凑内存图来检测加密恶意流量的未知模式。该图捕获由图结构特征表示的流交互模式，而不是特定已知攻击的特征。 我们开发了一种无监督图学习方法，通过分析图的连接性、稀疏性和统计特征来检测异常交互模式 建立了一个信息论模型来证明图保存的信息接近理想的理论边界。 Introduction 现有方法 深度数据包检测（DPI）的传统基于签名的方法在加密有效载荷的攻击下无效，加密流量具有与良性流量相似的特征，因此也可以逃避现有的基于机器学习。特别是，现有的加密流量检测方法受到监督，即依赖于已知攻击的先验知识，并且只能检测具有已知流量模式的攻击。此外，这些方法无法检测使用和不使用加密流量构建的攻击，并且由于加密和非加密攻击流量的特征显着不同，因此无法实现通用检测\n简而言之，现有方法无法实现无监督检测，也无法检测具有未知模式的加密恶意流量。特别是，加密的恶意流量具有隐蔽行为，这些方法无法捕获这些行为，这些方法根据单个流的模式检测攻击。但是，检测此类攻击流量仍然是可行的，因为即使攻击的单个流与良性攻击流相似，这些攻击涉及攻击者和受害者之间具有不同流交互的多个攻击步骤与良性流交互模式不同。\nHyperVision，这是一个实时检测系统，旨在通过分析流之间的交互模式来捕获加密恶意流量的足迹。特别是，它可以通过识别异常流交互（即不同于良性的交互模式）来检测具有未知足迹的加密恶意流。\n但是，构建用于实时检测的图形具有挑战性。我们不能简单地使用 IP 地址作为顶点，而传统的四元组流（源目的ip，源目的port）作为边来构建图，因为生成的密集图无法维持各种流之间的交互模式，例如，引起依赖爆炸问题 。\n收到流量尺寸分布的研究的启发，互联网上的大多数流都是短流，而大多数数据包与长流相关联，我们利用两种策略来记录不同大小的流，并在图中分别处理短流和长流的交互模式。\n我们设计了一种四步 轻量级 无监督 图学习方法，通过利用图上维护的丰富流交互信息来检测加密的恶意流量。\n首先，我们通过提取连通分量来分析图的连通性，并通过对高层次统计特征进行聚类来识别异常分量。通过排除良性分量，我们还显著减少了学习开销。 其次，我们根据在边特征中观察到的局部邻接关系对边进行预聚类。预聚类操作显著降低了特征处理开销，并确保了实时检测。 第三，我们使用Z3 SMT solver求解顶点覆盖问题来提取关键顶点，以最大程度地减少聚类的数量。 最后，根据每个临界顶点的连接边进行聚类，这些边位于预聚类产生的簇的中心，从而得到指示加密恶意流量的异常边。 此外，为了量化HyperVision基于图的流量记录相对于现有方法的优势，我们开发了一个流量记录熵模型，这是一个基于信息论的框架，从理论上分析恶意流量检测系统的现有数据源保留的信息量。这个框架表明NetFlow [19]和Zeek [86]无法保留高保真流量信息，而HyperVision中的图捕获了接近最优的流量信息，并且图中维护的信息量接近理想化数据源的理论上界。（这么屌啊？）此外，分析结果表明，HyperVision中的图形实现了比所有现有数据源更高的信息密度（即每单位存储的流量信息量），这是准确高效检测的基础。\n过两天读R. Zamir, “A proof of the fisher information inequality via a data processing argument,” IEEE Trans. Inf. Theory, vol. 44, no. 3, pp. 12461250, 1998.\n平台和数据集 我们使用英特尔的数据平面开发套件 （DPDK） [37] 对 HyperVision进行原型设计。为了广泛评估原型的性能，我们重放了92个攻击数据集，其中包括在我们的虚拟私有云 （VPC）中收集的80个新数据集，其中包含 1,500 多个实例。在 VPC 中，我们收集了 48 个典型的加密恶意流量，包括 （i） 加密泛洪流量，例如泛洪目标链路 [41];（ii） 网络攻击，例如利用网络漏洞 [64];（iii） 恶意软件活动，包括连接测试、依赖项更新和下载。\n此外，HyperVision 的平均检测吞吐量超过 100 Gb/s，平均检测延迟为 0.83 秒。\n省流 • 我们提出了 HyperVision，这是首个使用流交互图实现对未知模式的加密恶意流量进行实时无监督检测的方法。 • 我们开发了多种算法来构建内存中的图，使我们能够准确捕获不同流之间的交互模式。 • 我们设计了一种轻量级的无监督图形学习方法，通过图形特征来检测加密流量。 • 我们开发了一个由信息论建立的理论分析框架，以展示该图形捕获了接近最优的流量交互信息。 • 我们原型化了 HyperVision，并进行了广泛的实验，使用各种真实世界的加密恶意流量来验证其准确性和效率。\n名词解释 连通分量：在图论中，连通分量是一个图中的一个子图，其中任意两个顶点都可以通过边相连的路径相互访问。\nZ3 SMT solver：3（Z3 SMT solver）是由微软研究院开发的一个高性能的SMT（Satisfiability Modulo Theories）求解器。SMT 求解器是一种自动化工具，用于解决布尔公式、一阶逻辑公式和其他数学理论的判定问题。Z3 在各种计算机科学和工程领域都有广泛的应用，包括软件验证、形式化方法、人工智能、编译器优化和硬件验证等。\n英特尔的数据平面开发套件 （DPDK）：旨在优化数据包处理性能。它专注于高性能网络应用程序和数据平面开发，使开发人员能够在通用服务器硬件上实现高吞吐量和低延迟的数据包处理。它通过绕过操作系统内核，并在用户空间中实现网络协议栈，从而提供极低的延迟和高吞吐量。支持多核处理器，允许并行处理大量数据包。利用支持硬件加速的网络接口卡（NIC）来进一步提高性能。DPDK 是一个开源项目，开发人员可以根据其需求进行自定义和扩展。DPDK 通常用于构建高性能网络应用程序，如网络功能虚拟化（NFV）、防火墙、负载均衡、数据包过滤和路由等。它还用于云计算、边缘计算和网络设备。\nHyperVision 首先HyperVision以镜像来的路由器流量作为输入，确保不会干扰流量转发。在识别加密的恶意流量后，它可以与现有的中间恶意流量防御配合，以限制检测到的流量。重点检测使用加密流量构建的主动攻击。不考虑不会为受害者带来流量的被动攻击，例如流量窃听和被动流量分析\nHyperVision的设计目标如下：首先，它应该能够实现通用检测，即检测使用加密或非加密流量构建的攻击，从而确保攻击无法逃避流量加密的检测。其次，它能够实现实时高速流量处理，这意味着它可以识别通过加密流量是否是恶意的，同时产生低检测延迟。第三，HyperVision 执行的检测是不受监督的，这意味着它不需要任何加密恶意流量的先验知识。\n图构造 将流分为短流和长流，并分别记录它们的相互作用模式，以降低图的密度。\n使用不同的地址作为顶点，分别连接与短流和长流关联的边。聚合大量相似的短流，为一组短流构建一条边，从而减少维护流交互模式的开销。拟合长流中数据包特征的分布，构建与长流相关的边缘，从而保证了高保真记录的流交互模式，同时解决了传统方法中粗粒度流特征的问题。\n预处理图 通过提取连通分量来减少图的开销，并使用高级统计信息进行聚类。其中，聚类可以准确地检测出只有良性交互模式的组件，从而对这些良性组件进行过滤，减小图的规模。此外，我们进行了预聚类，并使用生成的聚类中心来表示图像中的识别的集群的边缘。（第五节详细讲）\n基于图的恶意流量检测 通过分析图特征来实现无监督加密恶意流量检测。\n图构造 流的分类 为了避免图构建过程中流之间的依赖爆炸，把流分成长流和短流，并且降低密度。下图显示了显示了2020年1月MAWI互联网流量数据集的流完成时间和流长度的分布，纵轴PDF是概率密度函数，可以看到不论是长流还是短流都在分布短时间、长长度更多。 利用短流合并后，图的稠密度显著下降 获取每个数据包的信息，并获取其源、目标地址、端口号和每个数据包的功能，包括协议、长度和到达间隔。我们开发了一种流量分类算法来对流量进行分类（附录A中的算法1）简单来说就是维护一个哈希表，键是hash(src,dest,src_post,dest_port)，值是流的所有数据包特征的序列(协议、数据包长度、到达间隔)，然后用一个定时器TIME_NOW，每隔JUDGE_INTERVAL检查一下，如果在这个interval里流发了多个数据包，就算他是长流，否则就说他是短流）【q，这个interval怎么设置？为什么后面说ssh暴力破解都是短流？这不是应该是短期发好多包吗？】\n短流聚合 我们观察到，大多数短流具有几乎相同的每个数据包的特征序列。我们设计了一种聚合短流的算法（附录A中的算法2）。当满足以下所有要求时，可以聚合一组流\n流具有相同的源和/或目标地址（为啥不是哈希表的键值一样） 流具有相同的协议类型 流的数量足够大，即当短流量的数量达到阈值AGG_LINE 我们为短流构建一条边，为所有流及其四个元组保留一个特征序列（即协议、数据包长度和到达间隔）\n长流的特征分布拟合 由于长流中的特征是集中分布的，我们使用直方图来表示长流中每个数据包特征的频率分布。直方图的每个条目表示一个数据包特征的频率，从而避免保留其长的每个数据包特征序列。具体来说，我们为每个长流中的每个数据包特征序列构建直方图，然后维护一个哈希表， 键为数据包特征序列，值为直方图。我们将数据包长度和到达间隔的桶宽度分别设置为 10 字节和 1 毫秒，以在拟合精度和开销之间进行权衡。 下图显示了数据集中的长流中已用桶的数量和最大桶的大小，可以看是集中分布的，即长流中的大多数数据包具有相似的包长度和到达间隔。长度拟合平均用11个桶，每个桶平均200个数据包；到达间隔拟合平均用121个桶，每个桶平均71个数据包。 ","date":"0001-01-01T00:00:00Z","permalink":"https://pillar23.github.io/p/","title":""}]